Q)Is JSX mandatory for React?
-No JSX is not mandatory for React
-It is just an easier appraoch of creating React elements with the help of babel 
as compared to React.createElement()
-It is more readable also 

Q)Is ES6 mandatory for React?
-No, ES6 is not mandatory for React.
-React itself is just a JavaScript library, so it works with plain ES5 JavaScript as well.
-However, ES6+ features (like class, arrow functions, let/const, import/export, destructuring) are commonly used in React code 
because they make components cleaner, shorter, and easier to maintain.
-Without ES6, you‚Äôd need to use older syntax like React.createClass instead of ES6 class components or use require() instead of 
import.

‚úÖ Example:

-With ES6:

class App extends React.Component {
  render() {
    return <h1>Hello</h1>;
  }
}


-Without ES6:

var App = React.createClass({
  render: function () {
    return React.createElement("h1", null, "Hello");
  }
});

Q)What is <React.Fragment></React.Fragment> and <></> ?
-In React, a component must return a single parent element.
-If you don‚Äôt want to wrap elements inside unnecessary <div> or other tags, you can use Fragments.
-A Fragment does not render any actual DOM element ‚Äî it‚Äôs ‚Äúinvisible.‚Äù
-Since it doesn‚Äôt produce a real node, you cannot apply CSS classes, inline styles, or attributes to it.

1. <React.Fragment></React.Fragment>
-This is the full syntax of a Fragment.
-It allows grouping multiple children without adding extra nodes to the DOM.
-Example:

return (
  <React.Fragment>
    <h1>Hello</h1>
    <p>World</p>
  </React.Fragment>
);


‚úÖ Output in DOM:

<h1>Hello</h1>
<p>World</p>

2. <> </> (Short Syntax)
-This is the shorthand for React.Fragment.
-Works the same, but it cannot take key or props.
üëâ Common interview point:
If you‚Äôre mapping an array and need to add a key, you must use <React.Fragment key={id}> instead of <>.

Example:

return (
  <>
    <h1>Hello</h1>
    <p>World</p>
  </>
);

Q)What is Virtual DOM?
-The Virtual DOM (VDOM) is basically a lightweight copy of the Real DOM that React (and other libraries like Vue) keeps in memory.
-The Real DOM is the actual structure in the browser that represents your webpage (all the <div>, <h1>, etc.).
-The Virtual DOM is like a JavaScript object version of the DOM that React uses to figure out what really changed, instead of updating the whole webpage every time.
-Why do we need it?
  -The Real DOM is slow to update, especially if the page is big. For example:
    -If you change one button‚Äôs text, without the Virtual DOM, the browser might need to re-check and repaint large parts of the 
    page.
    -With the Virtual DOM, React compares the old virtual DOM with the new virtual DOM (this process is called Diffing). Then it 
    updates only the parts of the Real DOM that actually changed, not the entire page.

Suppose your page looks like this:
<div>
  <h1>Hello User</h1>
  <button>Click Me</button>
</div>

If you update the <h1> from Hello User ‚Üí Hello Haren,

Without Virtual DOM ‚Üí Browser re-renders the whole <div>.
With Virtual DOM ‚Üí React sees that only <h1> text changed, so it updates only that node in the Real DOM.

-The Virtual DOM is like React‚Äôs middleman‚Äîinstead of directly working with the expensive Real DOM, React updates a cheap in-memory 
copy, figures out exactly what changed, and then makes the minimum number of updates to the actual browser DOM.

-In Short and Crisp
  -React uses the Virtual DOM to represent the UI in memory.
  -When state/props change ‚Üí React creates a new Virtual DOM tree.
  -It compares the old tree vs new tree ‚Üí finds differences.(diffing)
  -Then it updates only the changed parts in the Real DOM.

Q)What is Reconciliation in React?
-The process React uses to figure out what exactly changed in the UI and how to update the Real DOM efficiently.
-It has two key parts:
  1.Render Phase (Diffing Algorithm(Interruptible after React16 upgrade to React Fibre))
    -React compares the old and new Virtual DOM trees.
    -Instead of comparing node-by-node deeply (which would be very slow), React uses heuristics:
      -Different element types (e.g. <div> ‚Üí <span>) ‚Üí destroy old + create new.
      -Same type (e.g. <button> ‚Üí <button>) ‚Üí keep the node, update attributes.
      -Lists ‚Üí uses keys to track moved/added/removed items.
  2.Commit Phase(Non Interruptible)
    -Once differences are found, React applies minimal changes to the Real DOM.

üëâ So, Reconciliation is the brain behind deciding what to update.

Q)What is React Fiber?
-Before React 16 (Old Reconciliation / Stack Reconciler)
  -Updates were synchronous.
  -If your component tree was huge and you triggered an update, React would:
    -Build the whole Virtual DOM tree.
    -Diff it with the old one.
    -Apply updates.

Problem: The UI could freeze because React couldn‚Äôt pause the work in the middle.

Example: If a heavy component re-rendered, animations or user typing could feel laggy.

-React 16 and after ‚Üí React Fiber
  -React team introduced Fiber (completely rewritten reconciler) in React 16.
  -Fiber = New Virtual DOM Engine (not visible to us directly).

üîë Goals of Fiber:
-Interruptible Rendering
  -React can now pause rendering work if something more important happens (like a button click).
  -Example: Updating a large table ‚Üí React can pause in the middle, let you type smoothly, then continue.
-Prioritization
  -Not all updates are equally important.
  -Example: Animation frames > background data updates.
  -Fiber assigns priorities to updates.

-Incremental Rendering
  -Instead of rendering the whole tree at once, React can render it piece by piece.
  -This is possible because Fiber breaks the work into small units of work (called ‚Äúfibers‚Äù).

üü¢ How Fiber Works

Think of Fiber as:
  A linked list of nodes (instead of just a tree).
  Each Fiber node represents a React element (component, DOM node, etc.).
  Because it‚Äôs a linked structure, React can:
    Pause at any fiber.
    Resume later.
    Even throw away unfinished work if needed.

üü¢ Connecting the dots

Virtual DOM ‚Üí Representation of UI in memory.

Reconciliation ‚Üí Algorithm that compares old vs new Virtual DOM trees and decides what to update.

React Fiber ‚Üí New implementation of reconciliation (since React 16) that makes updates asynchronous, interruptible, and prioritized for smoother UIs.

Q)Example to show the importance of React Fibre.Also what is useTransition() ?
Example: Rendering a Huge List While Typing
Code:
import React, { useState } from "react";

export default function App() {
  const [text, setText] = useState("");

  // Big list of 5000 items
  const items = Array.from({ length: 5000 }, (_, i) => `Item ${i + 1}`);

  return (
    <div>
      <h2>Type something:</h2>
      <input
        type="text"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />

      <ul>
        {items.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

üü° Before React 16 (Old Reconciliation)
-When you type in the input:
  -React re-renders App.
  -The whole Virtual DOM tree (5000 <li> elements) is regenerated.
  -React synchronously compares old vs new.
  -UI freezes briefly before showing your typed character.

‚û°Ô∏è You would notice lag in typing because React couldn‚Äôt pause the reconciliation.

üü¢ After React 16 (with Fiber)
-When you type:
  -React starts re-rendering the Virtual DOM (5000 <li>).
  -React Fiber splits this into small units of work.
  -If something urgent happens (like typing input), React pauses the list rendering and handles the input update first.
  -Then it resumes list rendering without blocking user input.

‚û°Ô∏è The typing feels instant, even though React is still processing the big list in the background.

üü¢ Even Better: Using useTransition (React 18+)

React Fiber enables new APIs like Concurrent Rendering.
We can mark updates as low-priority:

import React, { useState, useTransition } from "react";

export default function App() {
  const [text, setText] = useState("");
  const [list, setList] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    setText(value);

    // Defer heavy work (low priority)
    startTransition(() => {
      const items = Array.from({ length: 5000 }, (_, i) => `${value} - Item ${i + 1}`);
      setList(items);
    });
  };

  return (
    <div>
      <h2>Type something:</h2>
      <input type="text" value={text} onChange={handleChange} />

      {isPending && <p>Loading list...</p>}

      <ul>
        {list.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}


‚úÖ Now typing is always smooth, because React prioritizes input updates over rendering the giant list.

Q)Why we need keys in React? 
-Keys help React identify which items have changed, been added, or removed when rendering lists.
-During Reconciliation, React compares the old and new Virtual DOM trees.
-Without keys, React may unnecessarily re-render or reorder DOM elements, causing performance issues or even bugs.

üëâ In short: Keys give each element a stable identity.

Q)When do we need keys in React?
-Whenever you render a list of elements dynamically (using .map() usually).

Example:

const items = ["Apple", "Banana", "Cherry"];

return (
  <ul>
    {items.map((item) => (
      <li key={item}>{item}</li>
    ))}
  </ul>
);

Without keys ‚Üí React won‚Äôt know which <li> corresponds to which item if the array changes.


Q)Can we use index as keys in React ?
-You might be tempted to use an item‚Äôs index in the array as its key. In fact, that‚Äôs what React will use if you don‚Äôt specify a 
key at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets 
reordered. Index as a key often leads to subtle and confusing bugs.
-Similarly, do not generate keys on the fly, e.g. with key={Math.random()}. This will cause keys to never match up between renders, 
leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input 
inside the list items. Instead, use a stable ID based on the data.
-Note that your components won‚Äôt receive key as a prop. It‚Äôs only used as a hint by React itself. If your component needs an ID, 
you have to pass it as a separate prop: <Profile key={id} userId={id} />.

Q)What is props in React ?
-Props/Properties are the arguments/data that we pass to a component

Q)What is a Config Driven UI ?
-Config Driven UI means building your UI in such a way that its structure, behavior, and content are controlled by configuration 
(usually JSON or some data), instead of hardcoding it in components.
-Config is the data coming from the api which keeps on changing according to different factors like user, location, etc. 